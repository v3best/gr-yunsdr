/* -*- c++ -*- */
/*
 * Copyright 2018 V3 Inc.
 *
 * GNU Radio is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 *
 * GNU Radio is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GNU Radio; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street,
 * Boston, MA 02110-1301, USA.
 */

/*
 * config.h is generated by configure.  It contains the results
 * of probing for features, options etc.  It should be the first
 * file included in your .cc file.
 */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdexcept>
#include <iostream>
#include <algorithm>

#include <boost/algorithm/string.hpp>
#include <boost/thread/thread.hpp>

#include <gnuradio/io_signature.h>

#include <volk/volk.h>
#include "yunsdr_ss_sink_impl.h"

namespace gr {
    namespace yunsdr {
        
        yunsdr_ss_sink::sptr
            yunsdr_ss_sink::make(const std::string &uri, unsigned long long frequency,
                    unsigned long samplerate,
                    unsigned long bandwidth, bool tx1_en, bool tx2_en,
                    double attenuation1,
                    double attenuation2,
                    const char *rf_port_select,
                    const std::string &ref_clock, 
                    const std::string &vco, 
                    unsigned int vco_param,
                    const char *filter, bool auto_filter)
            {
                return gnuradio::get_initial_sptr(
                        new yunsdr_ss_sink_impl(uri, frequency, samplerate, 
                            bandwidth, tx1_en, tx2_en, 
                            attenuation1, attenuation2, rf_port_select,
                            ref_clock, vco, vco_param,
                            filter, auto_filter));
            }

        /*
         * The private constructor
         */
        yunsdr_ss_sink_impl::yunsdr_ss_sink_impl(const std::string &uri, unsigned long long frequency, 
                unsigned long samplerate,
                unsigned long bandwidth, bool tx1_en, bool tx2_en,
                double attenuation1,
                double attenuation2,
                const char *rf_port_select,
                const std::string &ref_clock, 
                const std::string &vco, 
                unsigned int vco_param,
                const char *filter, bool auto_filter)
            : gr::sync_block("yunsdr_ss_sink",
                    gr::io_signature::make(
                        (int) tx1_en + (int) tx2_en,
                        (int) tx1_en + (int) tx2_en,
                        sizeof(gr_complex)),
                    gr::io_signature::make(0, 0, 0)),
            _ipaddr("pcie:0"),
            _dev(NULL)
        {
            int ret;

            _ipaddr = uri;
            std::cerr << "Using YunSDR URI = " << _ipaddr << std::endl;

            _dev = yunsdr_open_device(_ipaddr.c_str());
            if(_dev == NULL)
                throw std::runtime_error("Failed to open YunSDR device");

            std::cerr << "Using YunSDR with firmware [SDR]" << std::endl;

            ret = yunsdr_enable_timestamp(_dev, 0, 1);
            if ( ret < 0 )
                std::cerr << "Failed to enable YunSDR timestamp" << std::endl;

            if (ref_clock == "external")
                ret = yunsdr_set_ref_clock(_dev, 0, EXTERNAL_REFERENCE);
            else
                ret = yunsdr_set_ref_clock(_dev, 0, INTERNAL_REFERENCE);
            if ( ret < 0 )
                std::cerr << "Failed to configure YunSDR's reference clock to: " << ref_clock << std::endl;
            else
                std::cerr << "Configure YunSDR's ref_clock to " << ref_clock << std::endl;

            if (vco == "adf4001") {
                ret = yunsdr_set_vco_select(_dev, 0, ADF4001);
                //ret = yunsdr_set_adf4001(_dev, 0, vco_param);
            } else {
                ret = yunsdr_set_vco_select(_dev, 0, AUXDAC1);
                ret = yunsdr_set_auxdac1(_dev, 0, vco_param);
            }
            if ( ret < 0 )
                std::cerr << "Failed to configure YunSDR's VCO to " << vco << std::endl;
            else
                std::cerr << "Configure YunSDR's VCO to " << vco << std::endl;

            ret = yunsdr_set_rx_ant_enable(_dev, 0, 1);
            if ( ret < 0 )
                std::cerr << "Failed to configure YunSDR Antenna to TX" << std::endl;
            else
                std::cerr << "Configure YunSDR Antenna to TX" << std::endl;

            ret = yunsdr_set_duplex_select(_dev, 0, FDD);
            if ( ret < 0 )
                std::cerr << "Failed to configure YunSDR duplex mode to FDD"  << std::endl;
            else
                std::cerr << "Configure YunSDR duplex mode to FDD" << std::endl;

            set_params(frequency, samplerate, bandwidth, rf_port_select,
                    attenuation1, attenuation2, filter, auto_filter);

            if(tx1_en && tx2_en)
                tx_channel = 0xff;
            else if(tx1_en && !tx2_en)
                tx_channel = 1;
            else
                tx_channel = 2;
            std::cerr << "Using YunSDR  " << 
                (tx_channel == 0xff?"TX_DUALCHANNEL":
                 ((tx_channel == 1)?"TX1_CHANNEL":"TX2_CHANNEL")) 
                << std::endl;
        }

        /*
         * Our virtual destructor.
         */
        yunsdr_ss_sink_impl::~yunsdr_ss_sink_impl ()
        {
            int ret;
            if (_dev) {
                ret = yunsdr_close_device( _dev );
                if ( ret < 0 )
                {
                    std::cerr << "Failed to close YunSDR" << std::endl;
                }
                _dev = NULL;
            }
        }

        void yunsdr_ss_sink_impl::set_params(unsigned long long frequency,
                unsigned long samplerate, unsigned long bandwidth,
                const char *rf_port_select, double attenuation1,
                double attenuation2, const char *filter, bool auto_filter)
        {

            if (filter && filter[0])
                auto_filter = false;

            yunsdr_set_tx_lo_freq(_dev, 0, frequency);
            yunsdr_set_tx_sampling_freq(_dev, 0, samplerate);
            yunsdr_set_tx1_attenuation(_dev, 0, attenuation1*1000);
            yunsdr_set_tx2_attenuation(_dev, 0, attenuation2*1000);
            yunsdr_set_tx_rf_bandwidth(_dev, 0, bandwidth);

#if 0
            if (auto_filter) {
                int ret = ad9361_set_bb_rate(phy, samplerate);
                if (ret) {
                    throw std::runtime_error("Unable to set BB rate");
                }
            } else if (filter && filter[0]) {
                std::string f(filter);
                if (!device_source_impl::load_fir_filter(f, phy))
                    throw std::runtime_error("Unable to load filter file");
            }
#endif
        }

        int yunsdr_ss_sink_impl::work( int noutput_items,
                gr_vector_const_void_star &input_items,
                gr_vector_void_star &output_items )
        {
            int ret;
            const float scaling = 32768.0f;

            unsigned int count = (unsigned int)noutput_items;

            if(tx_channel == 0xff) {
                const gr_complex *in0 = (const gr_complex *) input_items[0];
                const gr_complex *in1 = (const gr_complex *) input_items[1];

                short iq0[count*2];
                short iq1[count*2];
                volk_32f_s32f_convert_16i(iq0, (float *)in0, scaling, 2 * count);
                volk_32f_s32f_convert_16i(iq1, (float *)in1, scaling, 2 * count);

                ret = yunsdr_write_samples(_dev, iq0, count, TX1_CHANNEL, 0);
                if( ret < 0 )
                    throw std::runtime_error("Unable to write samples to tx channel 1");

                ret = yunsdr_write_samples(_dev, iq1, count, TX2_CHANNEL, 0);
                if( ret < 0 )
                    throw std::runtime_error("Unable to write samples to tx channel 2");
            } else {
                const gr_complex *in = (const gr_complex *) input_items[0];
                short iq0[count*2];
                /* Convert floating point samples into fixed point */
                volk_32f_s32f_convert_16i(iq0, (float *)in, scaling, 2 * count);

                ret = yunsdr_write_samples(_dev, iq0, count, (tx_channel == 1?TX1_CHANNEL:TX2_CHANNEL), 0);
                if( ret < 0 )
                    throw std::runtime_error("Unable to write samples");
            }

            int items_consumed = count;
           
            // Tell runtime system how many input items we consumed on
            // each input stream.
            consume_each(items_consumed);

            // Tell runtime system how many output items we produced.
            return 0;
        }
        void
            yunsdr_ss_sink_impl::forecast(int noutput_items,
                    gr_vector_int &ninput_items_required)
            {
                for (unsigned int i = 0; i < ninput_items_required.size(); i++)
                    ninput_items_required[i] = noutput_items;
            }

    }
}
