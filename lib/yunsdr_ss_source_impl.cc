/* -*- c++ -*- */
/*
 * Copyright 2018 V3 Inc.
 *
 * GNU Radio is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 *
 * GNU Radio is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GNU Radio; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street,
 * Boston, MA 02110-1301, USA.
 */

/*
 * config.h is generated by configure.  It contains the results
 * of probing for features, options etc.  It should be the first
 * file included in your .cc file.
 */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdexcept>
#include <iostream>

#include <boost/assign.hpp>
#include <boost/format.hpp>
#include <boost/detail/endian.hpp>
#include <boost/algorithm/string.hpp>
#include <boost/thread/thread.hpp>

#include <gnuradio/io_signature.h>

#include <gnuradio/blocks/short_to_float.h>
#include <gnuradio/blocks/float_to_complex.h>

#include <volk/volk.h>
#include "yunsdr_ss_source_impl.h"

using namespace boost::assign;
using namespace gr::blocks;

namespace gr {
    namespace yunsdr {

        yunsdr_ss_source::sptr
            yunsdr_ss_source::make(const std::string &uri, unsigned long long frequency,
                    unsigned long samplerate,
                    unsigned long bandwidth,
                    bool rx1_en, bool rx2_en,
                    const char *gain1, double gain1_value,
                    const char *gain2, double gain2_value,
                    const std::string &ref_clock,
                    const std::string &vco,
                    unsigned int vco_param,
                    const char *rf_port_select, const char *filter,
                    bool auto_filter)
            {
                return gnuradio::get_initial_sptr
                    (new yunsdr_ss_source_impl(uri, frequency, 
                                            samplerate, bandwidth,
                                            rx1_en, rx2_en,
                                            gain1, gain1_value,
                                            gain2, gain2_value, 
                                            ref_clock, vco,
                                            vco_param,
                                            rf_port_select, filter,
                                            auto_filter));
            }

        yunsdr_ss_source_impl::yunsdr_ss_source_impl(const std::string &uri, unsigned long long frequency, 
                unsigned long samplerate,
                unsigned long bandwidth,
                bool rx1_en, bool rx2_en,
                const char *gain1, double gain1_value,
                const char *gain2, double gain2_value,
                const std::string &ref_clock,
                const std::string &vco,
                unsigned int vco_param,
                const char *rf_port_select, const char *filter,
                bool auto_filter)
            : gr::sync_block("yunsdr_ss_source",
                    gr::io_signature::make(0, 0, 0),
                    gr::io_signature::make(
                        (int) rx1_en + (int) rx2_en,
                        (int) rx1_en + (int) rx2_en,
                        sizeof(gr_complex))),
            _dev(NULL)

        {
            int ret;

            _ipaddr = uri;
            std::cerr << "Using YunSDR URI " << _ipaddr.c_str() << std::endl;

            _dev = yunsdr_open_device(_ipaddr.c_str());
            if(_dev == NULL)
                throw std::runtime_error("Failed to open YunSDR device.");

            std::cerr << "Using YunSDR with firmware [SDR]"<< std::endl;

            ret = yunsdr_enable_timestamp(_dev, 0, 1);
            if ( ret < 0 )
                std::cerr << "Failed to enable YunSDR timestamp " << std::endl;

            if (ref_clock == "external")
                ret = yunsdr_set_ref_clock(_dev, 0, EXTERNAL_REFERENCE);
            else
                ret = yunsdr_set_ref_clock(_dev, 0, INTERNAL_REFERENCE);

            if ( ret < 0 )
                std::cerr << "Failed to configure YunSDR's reference clock to : " << ref_clock << std::endl;
            else
                std::cerr << "Configure YunSDR's ref_clock to " << ref_clock << std::endl;

            if (vco == "adf4001") {
                ret = yunsdr_set_vco_select(_dev, 0, ADF4001);
                //ret = yunsdr_set_adf4001(_dev, 0, vco_param);
            } else {
                ret = yunsdr_set_vco_select(_dev, 0, AUXDAC1);
                ret = yunsdr_set_auxdac1(_dev, 0, vco_param);
            }
            if ( ret < 0 )
                std::cerr << "Failed to configure YunSDR's VCO to : " << vco << std::endl;
            else
                std::cerr << "Configure YunSDR's VCO to " << vco << " 1450 mV" << std::endl;

            if(!strcmp(rf_port_select, "TRX")) {
                ret = yunsdr_set_rx_ant_enable(_dev, 0, 0);
                if ( ret < 0 )
                    std::cerr << "Failed to configure YunSDR Antenna to RX " << std::endl;
                else
                    std::cerr << "Configure YunSDR Antenna to TRX A/B" << std::endl;

                ret = yunsdr_set_duplex_select(_dev, 0, TDD);
                if ( ret < 0 )
                    std::cerr << "Failed to configure YunSDR duplex mode to : TDD" << std::endl;
                else
                    std::cerr << "Configure YunSDR duplex mode to TDD" << std::endl;
            } else {
                ret = yunsdr_set_rx_ant_enable(_dev, 0, 1);
                if ( ret < 0 )
                    std::cerr << "Failed to configure YunSDR Antenna to RX: " << std::endl;
                else
                    std::cerr << "Configure YunSDR Antenna to RX" << std::endl;

                ret = yunsdr_set_duplex_select(_dev, 0, FDD);
                if ( ret < 0 )
                    std::cerr << "Failed to configure YunSDR duplex mode to : FDD" << std::endl;
                else
                    std::cerr << "Configure YunSDR duplex mode to FDD" << std::endl;
            }

            set_params(frequency, samplerate, bandwidth,
                    gain1, gain1_value,
                    gain2, gain2_value,
                    rf_port_select, filter, auto_filter);

            if(rx1_en && rx2_en)
                rx_channel = 0xff;
            else if(rx1_en && !rx2_en)
                rx_channel = 1;
            else
                rx_channel = 2;

            std::cerr << "Using YunSDR  " << 
                (rx_channel == 0xff?"RX_DUALCHANNEL":
                 ((rx_channel == 1)?"RX1_CHANNEL":"RX2_CHANNEL")) << std::endl; 
        }

        /*
         * Our virtual destructor.
         */
        yunsdr_ss_source_impl::~yunsdr_ss_source_impl ()
        {
            int ret;
            if (_dev) {
                ret = yunsdr_close_device( _dev );
                if ( ret < 0 ) {
                    std::cerr << "Failed to close YunSDR" << std::endl;
                }
                _dev = NULL;
            }
        }

        void yunsdr_ss_source_impl::set_params(unsigned long long frequency,
                unsigned long samplerate, unsigned long bandwidth,
                const char *gain1, double gain1_value,
                const char *gain2, double gain2_value,
                const char *port_select, const char *filter,
                bool auto_filter)
        {

            if (filter && filter[0])
                auto_filter = false;

            yunsdr_set_rx_lo_freq(_dev, 0, frequency);
            yunsdr_set_rx_sampling_freq(_dev, 0, samplerate);

            if(!strcmp(gain1, "fast_attack"))
                yunsdr_set_rx1_gain_control_mode(_dev, 0, RF_GAIN_FASTATTACK_AGC);
            else if(!strcmp(gain1, "slow_attack"))
                yunsdr_set_rx1_gain_control_mode(_dev, 0, RF_GAIN_SLOWATTACK_AGC);
            else {
                yunsdr_set_rx1_gain_control_mode(_dev, 0, RF_GAIN_MGC);
                yunsdr_set_rx1_rf_gain(_dev, 0, gain1_value);
            }

            if(!strcmp(gain2, "fast_attack"))
                yunsdr_set_rx2_gain_control_mode(_dev, 0, RF_GAIN_FASTATTACK_AGC);
            else if(!strcmp(gain2, "slow_attack"))
                yunsdr_set_rx2_gain_control_mode(_dev, 0, RF_GAIN_SLOWATTACK_AGC);
            else {
                yunsdr_set_rx2_gain_control_mode(_dev, 0, RF_GAIN_MGC);
                yunsdr_set_rx2_rf_gain(_dev, 0, gain2_value);
            }

            yunsdr_set_rx_rf_bandwidth(_dev, 0, bandwidth);
#if 0
            if (auto_filter) {
                int ret = ad9361_set_bb_rate(phy, samplerate);
                if (ret) {
                    throw std::runtime_error("Unable to set BB rate");
                }
            } else if (filter && filter[0]) {
                std::string filt(filter);
                if (!load_fir_filter(filt, phy))
                    throw std::runtime_error("Unable to load filter file");
            }
#endif
        }

        int yunsdr_ss_source_impl::work( int noutput_items,
                gr_vector_const_void_star &input_items,
                gr_vector_void_star &output_items )
        {
            int ret;
            const float scaling = 32768.0f;

            if(rx_channel == 0xff) {
                gr_complex *out0 = static_cast<gr_complex *>(output_items[0]);
                gr_complex *out1 = static_cast<gr_complex *>(output_items[1]);

                short iq0[noutput_items * 2];
                short iq1[noutput_items * 2];

                uint64_t timestamp = 0;
                ret = yunsdr_read_samples(_dev, iq0, noutput_items, RX1_CHANNEL, &timestamp);
                if(ret < 0)
                    throw std::runtime_error("Failed to read samples from rx channel1");
                timestamp = 0;
                ret = yunsdr_read_samples(_dev, iq1, noutput_items, RX2_CHANNEL, &timestamp);
                if(ret < 0)
                    throw std::runtime_error("Failed to read samples from rx channel2");
               
                volk_16i_s32f_convert_32f((float*)out0, iq0, scaling, 2*noutput_items);
                volk_16i_s32f_convert_32f((float*)out1, iq1, scaling, 2*noutput_items);

                return noutput_items;

            } else {
                gr_complex *out = static_cast<gr_complex *>(output_items[0]);
                short iq0[noutput_items * 2];
                uint64_t timestamp = 0;
                ret = yunsdr_read_samples(_dev, iq0, noutput_items, (rx_channel == 1?RX1_CHANNEL:RX2_CHANNEL), &timestamp);
                if(ret < 0)
                    throw std::runtime_error("Failed to read samples from rx channel1");
                
                volk_16i_s32f_convert_32f((float*)out, iq0, scaling, 2*noutput_items);

                return noutput_items;
            }
            //return noutput_items;
        }
    }
}
